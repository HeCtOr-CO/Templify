#region License

//-------------------------------------------------------------------------------------------------
// <auto-generated> 
// Marked as auto-generated so StyleCop will ignore BDD style tests
// </auto-generated>
//-------------------------------------------------------------------------------------------------

using System.Collections.Generic;
using Endjin.Templify.Domain.Contracts.Infrastructure;
using Endjin.Templify.Domain.Domain.Packager.Tokeniser;
using Endjin.Templify.Specifications;

using Machine.Specifications;
using Rhino.Mocks;

#pragma warning disable 169
// ReSharper disable InconsistentNaming
// ReSharper disable UnusedMember.Global
// ReSharper disable UnusedMember.Local

#endregion

namespace Endjin.Templify.Specifications
{
    #region Using Directives

    using System;
    using System.Collections.Generic;
    using System.IO;
    using System.Linq;

    using Endjin.Templify.Domain.Domain.Packager.Specifications;

    using Machine.Specifications;
    using Machine.Specifications.AutoMocking.Rhino;

    #endregion

    public abstract class specification_for_file_exclusion_specification : Specification<FileExclusionSpecification>
    {
        protected static List<string> file_list;
        protected static IConfiguration config;

        private Establish context = () =>
            {
                config = DependencyOf<IConfiguration>();
                config.Stub(x => x.GetFileExclusions()).Return(".cache,.mst,.msm,.gitignore,.idx,.pack,.user,.resharper,.suo");
                config.Stub(x => x.GetDirectoryExclusions()).Return("bin,obj,debug,release,.git");

                file_list = new List<string>
                    {
                        @"C:\__NAME__\.git\hooks\applypatch-msg.sample",
                        @"C:\__NAME__\bin\hooks\applypatch-msg.sample",
                        @"C:\__NAME__\obj\hooks\applypatch-msg.sample",
                        @"C:\__NAME__\debug\hooks\applypatch-msg.sample",
                        @"C:\__NAME__\release\hooks\applypatch-msg.sample",
                        @"C:\__NAME__\hooks\applypatch-msg.cache",
                        @"C:\__NAME__\hooks\applypatch-msg.mst",
                        @"C:\__NAME__\hooks\.gitignore",
                        @"C:\__NAME__\hooks\applypatch-msg.idx",
                        @"C:\__NAME__\hooks\applypatch-msg.pack",
                        @"C:\__NAME__\hooks\applypatch-msg.user",
                        @"C:\__NAME__\hooks\applypatch-msg.resharper",
                        @"C:\__NAME__\hooks\applypatch-msg.suo",
                    };
            };
    } ;

    [Subject(typeof(FileExclusionSpecification))]
    public class when_the_file_exclusion_specification_is_given_a_list_of_items_to_exclude : specification_for_file_exclusion_specification
    {
        static FileExclusionSpecification subject;
        static IEnumerable<string> result;

        Establish context = () =>
            {
                subject = new FileExclusionSpecification(config);
            };

        Because of = () => result = subject.SatisfyingElementsFrom(file_list.AsQueryable());

        It should_get_the_list_of_file_exclusions_from_config = () =>
            config.AssertWasCalled(x => x.GetFileExclusions());

        It should_get_the_list_of_directory_exclusions_from_config = () =>
            config.AssertWasCalled(x => x.GetDirectoryExclusions());

        It should_return_no_files = () => result.Count().ShouldEqual(0);
    }
}